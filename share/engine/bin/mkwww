#!/usr/bin/python3
"""
Minimalist engine for building a minimalist static website.

Examples
========

::

  $ mkwww             # Run tests, first building all targets.
  $ mkwww recheck     # Run tests again, even if no source files changed.
  $ mkwww -t clean    # Clean all targets.
  $ mkwww wipe        # Thoroughly clean build directories.
  $ mkwww all         # Build all targets only, don't run tests.
  $ mkwww wipe check  # Wipe, build, then run tests.
  $ mkwww serve check # Serve the site; build and run tests on every request.

Tests include a link checker to ensure no broken links, in both your website
source and the links generated by mkww.

Usage
=====

Control the source/build directories via envvars::

  THEME = "default" # theme directory, relative to themes directory
  SRC   = "src"     # source input directory
  GEN   = "build"   # intermediate build directory
  DST   = "dist"    # final output for publishing

Control the output via envvars::

  MKWWW_DEV = 1     # Pages auto-refresh after 4s. Useful with ``mkwww serve``

Convenience targets in build.ninja:

``all``:
  Build all targets

``check``:
  Run tests

``recheck``:
  Run tests unconditionally

Fine-grained command control::

  Usage: mkwww [<steps>] <ninja args>

<steps> is a comma-separated (no spaces) list denoting which pre-ninja steps to
run. If not given, ``gen,run`` is implied. Possible steps are:

``wipe``:
  Wipe ``GEN`` and ``DST`` before everything else.

  To help common publishing use-cases, the top-level ``DST`` directory is kept,
  as well as certain special files, e.g. ``.git`` or ``.nojekyll``.

``gen``:
  Generate or regenerate build.ninja, unconditionally.

``run``:
  Run ninja with <ninja args>, first generating build.ninja if out-of-date.

``auto``:
  Run ninja with <ninja args>, repeatedly until it fails.

  Good for development when you don't want to keep running mkwww manually.

``serve``:
  Run an HTTP server on port 8000 or the PORT envvar, handling requests by
  first running ninja with <ninja args> <http-request-path>.

  Use shift-reload to force a rebuild of the requested page.

  Use shift-reload on the root path / to force a rebuild of the whole site.

  Good for development when you don't want to run a web server manually.

The steps must be given in sequence, as follows::

  wipe -> gen -> (run | auto)

You can omit any of the steps, as long as what you give is in sequence.
"""

import itertools
import json
import os
import pathlib
import subprocess
import sys
import time

env = os.getenv
## variable dirs, read from the environment, set by user
THEME = env("THEME", "default")
SRC = env("SRC", "src")
GEN = env("GEN", "build")
DST = env("DST", "dist")

rel = os.path.relpath
cwd = os.getcwd()
rp = os.path.realpath
pj = os.path.join

## static dirs, relevant to the mkwww installation
BIN_ABS = os.path.dirname(rp(__file__)).removesuffix("/")
BIN     = rel(BIN_ABS, cwd)
ENG_ABS = rp(pj(BIN, ".."))
ENG     = rel(ENG_ABS, cwd)
THM_ABS = rp(pj(ENG, "../themes", THEME))
THM     = rel(THM_ABS, cwd)
ENGSRC  = pj(ENG, "common")
THMSRC  = pj(THM, "common")
# supported formats, extension in upper case.
# to add another format, implement ${BIN}/${fmt}2main then add it to this list
SRC_FORMATS = "MD RST ADOC".split()
CONFIG_GLOBALS = [
  "THEME", "SRC", "GEN", "DST",
  "BIN_ABS", "BIN", "ENG_ABS", "ENG", "THM_ABS", "THM", "ENGSRC", "THMSRC",
  "SRC_FORMATS",
]

## derived variable dirs
CFG = pj(GEN, "build.ninja.json")
OUT = pj(GEN, "build.ninja")
TRUE = ("1", "yes", "on", "true")
FALSE = ("0", "no", "off", "false")
CFGLOADED = False

def intersect(l0, l1):
  return sorted(frozenset(l0) & frozenset(l1))

def filterout(l0, l1):
  return sorted(frozenset(l1) - frozenset(l0))

def list_files(base):
  for p, _, ff in os.walk(base):
    for f in ff:
      yield pj(p, f)

def list_dirs(base):
  if os.path.isdir(base):
    yield base
  for p, dd, _ in os.walk(base):
    for d in dd:
      yield pj(p, d)

def out_of_date(target, source):
  if not os.path.exists(target):
    return True
  if not os.path.exists(source):
    return True
  ttime = os.path.getmtime(target)
  if ttime < os.path.getmtime(source):
    return True
  if os.path.isdir(source):
    # if target is a directory, check all subdir modtimes too
    for p, dd, _ in os.walk(source):
      for d in dd:
        if ttime < os.path.getmtime(pj(p, d)):
          return True
  return False

def read_site():
  # Note: please keep read_site_deps updated with this function
  with open("%s/site.json" % ENG) as fp:
    e = json.load(fp)
  with open("%s/site.json" % SRC) as fp:
    s = json.load(fp)
  t = e | s
  return (t["dir_common"], t["dir_include"], e.get("dir_nodst",[]) + s.get("dir_nodst",[]))

def read_site_deps():
  return ["%s/site.json" % ENG, "%s/site.json" % SRC]

def rel_any(path):
  p = pathlib.Path(path)
  for n, d in [("$"+k, globals()[k]) for k in ("SRC", "GEN", "DST", "ENGSRC", "THMSRC", "ENG")]:
    dp = pathlib.Path(d)
    if dp == p or dp in p.parents:
      rp = rel(p, d)
      return n if rp == "." else pj(n, rp)
  return path

def detect_pythonpath():
  if env("MKWWW_BIN", ""):
    # running inside mkwww already, e.g. via ninja regenerate
    # in this case "import mkwww" will always succeed even if it should fail
    # so just return the existing value
    return env("PYTHONPATH", "")
  try:
    import mkwww
  except ImportError:
    return "%s/../../lib/python3:%s" % (ENG_ABS, env("PYTHONPATH", ""))

def mk_config():
  # Note: please keep mk_config_deps updated with this function
  MKWWW_NINJA_HEADER = """# THIS FILE IS AUTOMATICALLY GENERATED. ANY EDITS WILL BE OVERWRITTEN.
#
# This file expects to be run via mkwww.
# You can run it directly via ninja but you may have to ensure the following environment:
""".rstrip().split("\n")
  MKWWW_NINJA_HEADER += ["# cd %s" % cwd]
  MKWWW_NINJA_HEADER += ["# MKWWW_BIN=%s" % BIN_ABS]
  PYTHONPATH = detect_pythonpath()
  if PYTHONPATH:
    MKWWW_NINJA_HEADER += ["# PYTHONPATH=%s" % PYTHONPATH]
  else:
    del PYTHONPATH
  # only record the config here, we set os.environ later. this decomposes better.
  MKWWW_DEV = env("MKWWW_DEV", "") in TRUE
  # depending on a directory (and its subdirs) means we depend on the list of files inside that directory
  # ninja doesn't apply recursion logic to directory dependencies, so we do it here
  GENERATE_DEPS = [rel_any(d) for x in mk_config_deps() for d in (list_dirs(x) if os.path.isdir(x) else [x])]

  DIR_COMMON, DIR_INCLUDE, DIR_NODST = read_site()
  ENGDST = pj(DST, DIR_COMMON, "engine")
  THMDST = pj(DST, DIR_COMMON, "theme")

  # TODO: handle the case where GEN/DST are underneath SRC
  SRC_ALL = sorted(filter(lambda x: not any(x.startswith(pj(SRC, p)) for p in [DIR_INCLUDE] + DIR_NODST), list_files(SRC)))
  SRC_D = {}
  IOV_D = {}
  SRC_OV_D = {}
  SRC_NV_D = {}
  INF_OV_D = {}
  INF_NV_D = {}
  INF_D = {}
  DEP_D = {}
  DST_D = {}
  IOV_ALL = []
  INF_OV_ALL = []
  INF_NV_ALL = []
  INF_ALL = []
  SRC_NONCOPY = []
  DEP_NONCOPY = []
  DST_NONCOPY = []

  gen_INF = lambda x: pj(GEN, rel(x, SRC)+".json")
  gen_DEP = lambda x: pj(GEN, rel(x, SRC)+".d")
  dst_SRC = lambda x: pj(DST, rel(x, SRC))
  dst_ENG = lambda x: pj(ENGDST, rel(x, ENGSRC))
  dst_THM = lambda x: pj(THMDST, rel(x, THMSRC))
  re_suf = lambda a, x, y: a.removesuffix(x)+y

  def def_fmt_vars(FMT, ext, isuf, osuf):
    SRC_D[FMT] = list(filter(lambda x: x.endswith("."+ext), SRC_ALL))
    IOV_D[FMT] = list(filter(lambda x: x.endswith("."+ext+".json"), SRC_ALL))
    SRC_OV_D[FMT] = [x.removesuffix(".json") for x in intersect([x+".json" for x in SRC_D[FMT]], IOV_D[FMT])]
    SRC_NV_D[FMT] = filterout(SRC_OV_D[FMT], SRC_D[FMT])
    INF_OV_D[FMT] = list(map(gen_INF, SRC_OV_D[FMT]))
    INF_NV_D[FMT] = list(map(gen_INF, SRC_NV_D[FMT]))
    INF_D[FMT] = list(map(gen_INF, SRC_D[FMT]))
    DEP_D[FMT] = list(map(lambda x: gen_DEP(re_suf(x, isuf, osuf)), SRC_D[FMT]))
    DST_D[FMT] = list(map(lambda x: dst_SRC(re_suf(x, isuf, osuf)), SRC_D[FMT]))

    # filter out our special handling of .html.j2
    if "."+ext == isuf:
      IOV_ALL.extend(IOV_D[FMT])
      INF_OV_ALL.extend(INF_OV_D[FMT])
      INF_NV_ALL.extend(INF_NV_D[FMT])
      INF_ALL.extend(INF_D[FMT])
      SRC_NONCOPY.extend(SRC_D[FMT])
      DEP_NONCOPY.extend(DEP_D[FMT])
      DST_NONCOPY.extend(DST_D[FMT])

  # path variables
  def_fmt_vars("J2", "j2", ".j2", "")
  def_fmt_vars("HTML_J2", "html.j2", ".j2", "") # for sitenav - subset of *.j2 files that are *.html.j2
  for fmt in SRC_FORMATS:
    def_fmt_vars(fmt, fmt.lower(), "."+fmt.lower(), ".html")

  SRC_SPEC = [ pj(SRC, "site.json") ]
  SRC_COPY = filterout(IOV_ALL + SRC_SPEC + SRC_NONCOPY, SRC_ALL)
  DST_COPY = list(map(dst_SRC, SRC_COPY))
  DST_ENG = sorted(map(dst_ENG, list_files(ENGSRC)))
  DST_ENG_CSS = list(filter(lambda x: x.endswith(".css"), DST_ENG))
  DST_ENG_COPY = filterout(DST_ENG_CSS, DST_ENG)
  DST_THM = sorted(map(dst_THM, list_files(THMSRC)))
  DST_ALL = DST_NONCOPY + DST_COPY + DST_ENG + DST_THM

  return {
    k: globals()[k]
    for k in CONFIG_GLOBALS
  } | {
    k: v
    for k, v in locals().items()
    if k.isupper() and not callable(v)
  }

def mk_config_deps():
  # arguments of all list_files() calls in mk_config
  return read_site_deps() + [SRC, ENGSRC, THMSRC]

def wipe(_=None):
  # This is implemented outside of ninja rather than inside as a "phony target"
  # because targets are meant to be additive not subtractive. Implementing
  # subtractive "clean" targets in build systems that cannot distinguish
  # between additive vs subtractive targets (i.e. most if not all of them),
  # causes problems when running targets in parallel.
  import shutil

  if not os.path.isdir(SRC):
    raise ValueError("SRC not a directory: %s" % SRC)

  if os.path.exists(GEN):
    print("mkwww: wipe: removing:", GEN)
    shutil.rmtree(GEN)
  if os.path.exists(DST):
    print("mkwww: wipe: removing contents of:", DST)
    for e in os.scandir(DST):
      if e.is_dir(follow_symlinks=False):
        shutil.rmtree(e.path)
      elif e.name not in (".git", ".nojekyll"): # keep certain files to help with publishing
        os.remove(e.path)

def env_run(*args, **kwargs):
  global CFGLOADED
  if not CFGLOADED:
    with open(CFG) as fp:
      ctx = json.load(fp)

    if "BIN_ABS" in ctx:
      os.environ["MKWWW_BIN"] = ctx["BIN_ABS"]
    if "PYTHONPATH" in ctx:
      os.environ["PYTHONPATH"] = ctx["PYTHONPATH"]

    CFGLOADED = True
  return subprocess.run(*args, **kwargs)

def gen(_=None):
  # Note: this should unconditionally regenerate, because it is defined as the
  # generator rule in build.ninja, which expects its command to work
  # unconditionally, the conditioning being done in logic inside ninja.
  print("mkwww: gen: generating:", CFG, OUT)
  config = mk_config()

  os.makedirs(os.path.dirname(CFG), exist_ok=True)
  with open(CFG, "w") as fp:
    json.dump(config, fp, indent=2)

  return env_run([
    pj(BIN, "j2-env.py"),
    pj(BIN, "build.ninja.j2"),
    CFG,
    OUT,
    pj(GEN, "build.ninja.d"),
  ], check=True).returncode

def runx(args, **kwargs):
  if out_of_date(OUT, CFG) or any(out_of_date(CFG, x) for x in mk_config_deps()):
    print("mkwww: run: out of date:", CFG, OUT)
    gen()

  return env_run([
    "ninja", "-f", OUT
  ] + args, **kwargs)

def run(args):
  return runx(args).returncode

def runall(it, sleep=0):
  for f, a in it:
    exitcode = f(a)
    if exitcode:
      return exitcode
    time.sleep(sleep)
  return 0

def auto(args):
  return runall(itertools.repeat((run, args)), 4)

def serve(args):
  import traceback
  from http.server import HTTPStatus, ThreadingHTTPServer, SimpleHTTPRequestHandler, test

  class NinjaHandler(SimpleHTTPRequestHandler):
    def do_GET(self):
      rebuild = self.headers.get('Cache-Control', "") == "no-cache"
      try:
        if self.path == "/":
          patharg = []
        else:
          patharg = [self.translate_path(self.path)]
        if rebuild:
          print("mkwww/serve: clean", patharg)
          proc = runx(args + ["-t", "clean"] + patharg, capture_output=True)
          proc.check_returncode()
        print("mkwww/serve: build", patharg)
        proc = runx(args + patharg, capture_output=True)
        proc.check_returncode()
        return super().do_GET()

      except Exception as e:
        self.send_response(HTTPStatus.INTERNAL_SERVER_ERROR)
        self.send_header("Content-type", "text/plain")
        self.end_headers()
        error = "error building %s:\n\n" % self.path
        self.wfile.write(error.encode("utf-8"))
        self.wfile.write(traceback.format_exc().encode("utf-8"))
        if isinstance(e, subprocess.CalledProcessError):
          self.wfile.write("\nstderr\n======\n\n".encode("utf-8"))
          self.wfile.write(proc.stderr)
          self.wfile.write("\nstdout\n======\n\n".encode("utf-8"))
          self.wfile.write(proc.stdout)
        return

  class NinjaServer(ThreadingHTTPServer):
    def finish_request(self, request, client_address):
      self.RequestHandlerClass(request, client_address, self, directory=DST)

  test(
    HandlerClass=NinjaHandler,
    ServerClass=NinjaServer,
    port=env("PORT", "8000"),
  )

STEPS = {
  "wipe": (0, wipe),
  "gen": (1, gen),
  "run": (2, run),
  "auto": (2, auto),
  "serve": (2, serve),
}

def extract_steps(args):
  steps = (args[0] if len(args) else "").split(",")
  if len(steps) == 1 and steps[0] not in STEPS:
    # default case, no explicit steps
    steps = ["run"]
  else:
    # explicit steps, pop args
    args = args[1:]

  # if there are ninja args, append run step
  if args and STEPS[steps[-1]][0] < STEPS["run"][0]:
    steps.append("run")

  stepinfo = [STEPS[n] for n in steps]
  if any(y[0] <= x[0] for x, y in zip(stepinfo[:-1], stepinfo[1:])):
    raise ValueError("steps not in sequence: %s" % steps)

  return [s[1] for s in stepinfo], args

def main(*args):
  if not os.path.isdir(SRC):
    raise ValueError("SRC not a directory: %s" % SRC)

  steps, args = extract_steps(list(args))
  return runall((s, args) for s in steps)

if __name__ == "__main__":
  sys.exit(main(*sys.argv[1:]))
