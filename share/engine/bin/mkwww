#!/usr/bin/python3
"""
Minimalist engine for building a minimalist static website.

Examples
========

::

  $ mkwww             # Run tests, first building all targets.
  $ mkwww recheck     # Run tests again, even if no source files changed.
  $ mkwww all         # Build all targets only, don't run tests.
  $ mkwww -t clean    # Clean all targets.
  $ mkwww wipe        # Thoroughly clean build directories.
  $ mkwww wipe check  # Wipe, build, then run tests.
  $ mkwww serve check # Serve the site; build and run tests on every request.

Tests include a link checker to ensure no broken links, in both your website
source and the links generated by mkwww.

Usage
=====

Control the source/build directories via envvars::

  THEME = "default" # theme directory, relative to themes directory
  SRC   = "src"     # source input directory
  GEN   = "build"   # intermediate build directory
  DST   = "dist"    # final output for publishing

Control the output via envvars::

  MKWWW_DEV = 1     # Pages auto-refresh after 4s. Useful with ``mkwww serve``

Convenience targets in build.ninja:

``all``:
  Build all targets

``check``:
  Run tests

``recheck``:
  Run tests unconditionally

Fine-grained command control::

  Usage: mkwww [<steps>] <ninja args>

<steps> is a comma-separated (no spaces) list denoting which special steps to
run. If not given, ``make`` is implied. Possible steps are:

``wipe``:
  Wipe ``GEN`` and ``DST`` before everything else.

  To help common publishing use-cases, the top-level ``DST`` directory is kept,
  as well as certain special files, e.g. ``.git`` or ``.nojekyll``.

``conf``:
  Detect build configuration and generate build.ninja, unconditionally.

``make``:
  Run ninja with <ninja args>, first generating build.ninja if out-of-date.

``auto``:
  Run ninja with <ninja args>, repeatedly until it fails.

  Good for development when you don't want to keep running mkwww manually.

``serve``:
  Run an HTTP server on port 8000 or the PORT envvar, handling requests by
  first running ninja with <ninja args> <http-request-path>.

  Use shift-reload to force a rebuild of the requested page.

  Use shift-reload on the root path / to force a rebuild of the whole site.

  Good for development when you don't want to run a web server manually.

The steps must be given in sequence, as follows::

  wipe -> conf -> (make | auto | serve)

You can omit any of the steps, as long as what you give is in sequence.
"""

import njinja

import itertools
import json
import os
import subprocess
import sys
import time

env = os.getenv
## variable dirs, read from the environment, set by user
THEME = env("THEME", "default")
SRC = env("SRC", "src")
GEN = env("GEN", "build")
DST = env("DST", "dist")

rel = os.path.relpath
cwd = os.getcwd()
rp = os.path.realpath
pj = os.path.join

## static dirs, relevant to the mkwww installation
BIN_ABS = os.path.dirname(rp(__file__)).removesuffix("/")
BIN     = rel(BIN_ABS, cwd)
ENG_ABS = rp(pj(BIN, ".."))
ENG     = rel(ENG_ABS, cwd)
THM_ABS = rp(pj(ENG, "../themes", THEME))
THM     = rel(THM_ABS, cwd)
ENGSRC  = pj(ENG, "common")
THMSRC  = pj(THM, "common")
# supported formats, extension in upper case.
# to add another format, implement ${BIN}/${fmt}2main then add it to this list
SRC_FORMATS = "MD RST ADOC".split()
CONFIG_GLOBALS = [
  "THEME", "SRC", "GEN", "DST",
  "BIN_ABS", "BIN", "ENG_ABS", "ENG", "THM_ABS", "THM", "ENGSRC", "THMSRC",
  "SRC_FORMATS",
]

## derived variable dirs
CFG = pj(GEN, "build.ninja.json")
OUT = pj(GEN, "build.ninja")
TRUE = ("1", "yes", "on", "true")
FALSE = ("0", "no", "off", "false")
CFGLOADED = False

def detect_pythonpath():
  if env("MKWWW_BIN", ""):
    # running inside mkwww already, e.g. via ninja regenerate
    # in this case "import mkwww" will always succeed even if it should fail
    # so just return the existing value
    return env("PYTHONPATH", "")
  try:
    import mkwww
  except ImportError:
    oldpath = env("PYTHONPATH", "")
    return "%s/../../lib/python3" % ENG_ABS + (":" + oldpath if oldpath else "")

def mk_config():
  bcfg = njinja.BuildConfig()

  PYTHONPATH = detect_pythonpath()
  if not PYTHONPATH:
    del PYTHONPATH

  MKWWW_DEV = env("MKWWW_DEV", "") in TRUE

  def read_site():
    with bcfg.open("%s/site.json" % ENG) as fp:
      e = json.load(fp)
    with bcfg.open("%s/site.json" % SRC) as fp:
      s = json.load(fp)
    t = e | s
    return (t["dir_common"], t["dir_include"], e.get("dir_nodst",[]) + s.get("dir_nodst",[]))

  DIR_COMMON, DIR_INCLUDE, DIR_NODST = read_site()
  ENGDST = pj(DST, DIR_COMMON, "engine")
  THMDST = pj(DST, DIR_COMMON, "theme")

  # TODO: handle the case where GEN/DST are underneath SRC
  SRC_ALL = sorted(filter(lambda x: not any(x.startswith(pj(SRC, p)) for p in [DIR_INCLUDE] + DIR_NODST), bcfg.walk_files(SRC)))
  SRC_D = {}
  IOV_D = {}
  SRC_OV_D = {}
  SRC_NV_D = {}
  INF_OV_D = {}
  INF_NV_D = {}
  INF_D = {}
  DEP_D = {}
  DST_D = {}
  IOV_ALL = []
  INF_OV_ALL = []
  INF_NV_ALL = []
  INF_ALL = []
  SRC_NONCOPY = []
  DEP_NONCOPY = []
  DST_NONCOPY = []

  gen_INF = lambda x: pj(GEN, rel(x, SRC)+".json")
  gen_DEP = lambda x: pj(GEN, rel(x, SRC)+".d")
  dst_SRC = lambda x: pj(DST, rel(x, SRC))
  dst_ENG = lambda x: pj(ENGDST, rel(x, ENGSRC))
  dst_THM = lambda x: pj(THMDST, rel(x, THMSRC))
  re_suf = lambda a, x, y: a.removesuffix(x)+y

  def def_fmt_vars(FMT, ext, isuf, osuf, disj=True, src_all=SRC_ALL):
    SRC_D[FMT] = list(filter(lambda x: x.endswith("."+ext), src_all))
    IOV_D[FMT] = list(filter(lambda x: x.endswith("."+ext+".json"), src_all))
    SRC_OV_D[FMT] = [x.removesuffix(".json") for x in njinja.intersect([x+".json" for x in SRC_D[FMT]], IOV_D[FMT])]
    SRC_NV_D[FMT] = njinja.filterout(SRC_OV_D[FMT], SRC_D[FMT])
    INF_OV_D[FMT] = list(map(gen_INF, SRC_OV_D[FMT]))
    INF_NV_D[FMT] = list(map(gen_INF, SRC_NV_D[FMT]))
    INF_D[FMT] = list(map(gen_INF, SRC_D[FMT]))
    DEP_D[FMT] = list(map(lambda x: gen_DEP(re_suf(x, isuf, osuf)), SRC_D[FMT]))
    DST_D[FMT] = list(map(lambda x: dst_SRC(re_suf(x, isuf, osuf)), SRC_D[FMT]))

    if disj:
      IOV_ALL.extend(IOV_D[FMT])
      INF_OV_ALL.extend(INF_OV_D[FMT])
      INF_NV_ALL.extend(INF_NV_D[FMT])
      INF_ALL.extend(INF_D[FMT])
      SRC_NONCOPY.extend(SRC_D[FMT])
      DEP_NONCOPY.extend(DEP_D[FMT])
      DST_NONCOPY.extend(DST_D[FMT])

  # path variables
  src_non_fmt = set(SRC_ALL)
  for fmt in SRC_FORMATS:
    fmt_ = fmt.lower()
    def_fmt_vars(fmt + "_J2", fmt_ + ".j2", ".%s.j2" % fmt_, ".html")
    def_fmt_vars(fmt, fmt_, "."+fmt_, ".html")
    src_non_fmt -= set(SRC_D[fmt + "_J2"])
  def_fmt_vars("J2", "j2", ".j2", "", src_all=src_non_fmt)
  def_fmt_vars("HTML_J2", "html.j2", ".j2", "", False)

  SRC_SPEC = [ pj(SRC, "site.json") ]
  SRC_COPY = njinja.filterout(IOV_ALL + SRC_SPEC + SRC_NONCOPY, SRC_ALL)
  DST_COPY = list(map(dst_SRC, SRC_COPY))
  DST_ENG = sorted(map(dst_ENG, bcfg.walk_files(ENGSRC)))
  DST_ENG_CSS = list(filter(lambda x: x.endswith(".css"), DST_ENG))
  DST_ENG_COPY = njinja.filterout(DST_ENG_CSS, DST_ENG)
  DST_THM = sorted(map(dst_THM, bcfg.walk_files(THMSRC)))
  DST_ALL = DST_NONCOPY + DST_COPY + DST_ENG + DST_THM

  return bcfg.collect_config(
    locals(),
    globals(),
    lambda k: k in CONFIG_GLOBALS,
    extra_dirs=[GEN, DST, ENG]
  )

def mk_ninja(force=False):
  headers="""This file was automatically generated. ANY EDITS WILL BE LOST.

This file expects to be run via mkwww.
You can run it directly via ninja but you may have to ensure the following environment:

cd %s
MKWWW_BIN={BIN_ABS}
PYTHONPATH={PYTHONPATH}
""" % cwd
  return njinja.mk_ninja(
    pj(BIN, "build.ninja.j2"), mk_config, GEN, headers=headers, force=force)

def wipe(_=None):
  # This is implemented outside of ninja rather than inside as a "phony target"
  # because targets are meant to be additive not subtractive. Implementing
  # subtractive "clean" targets in build systems that cannot distinguish
  # between additive vs subtractive targets (i.e. most if not all of them),
  # causes problems when running targets in parallel.
  import shutil

  if not os.path.isdir(SRC):
    raise ValueError("SRC not a directory: %s" % SRC)

  if os.path.exists(GEN):
    print("mkwww/wipe: removing:", GEN)
    shutil.rmtree(GEN)
  if os.path.exists(DST):
    print("mkwww/wipe: removing contents of:", DST)
    for e in os.scandir(DST):
      if e.is_dir(follow_symlinks=False):
        shutil.rmtree(e.path)
      elif e.name not in (".git", ".nojekyll"): # keep certain files to help with publishing
        os.remove(e.path)

def conf(_=None):
  # This unconditionally builds build.ninja and is therefore appropriate to
  # be defined as generator rule in build.ninja.
  mk_ninja(force=True)

def maybe_ninja(args, **kwargs):
  cmdline = mk_ninja()
  if "ninja" in cmdline:
    # everything succeeded, now set the environment
    with open(CFG) as fp:
      config = json.load(fp)
      os.environ["MKWWW_BIN"] = config.get("BIN_ABS", "")
      os.environ["PYTHONPATH"] = config.get("PYTHONPATH", "")
  return subprocess.run(cmdline + list(args), **kwargs)

def make(args):
  return maybe_ninja(args).returncode

def runall(it, sleep=0):
  for f, a in it:
    exitcode = f(a)
    if exitcode:
      return exitcode
    time.sleep(sleep)
  return 0

def auto(args):
  return runall(itertools.repeat((make, args)), 4)

def serve(args):
  import threading
  import traceback
  from http.server import HTTPStatus, ThreadingHTTPServer, SimpleHTTPRequestHandler, test

  # can drop this lock once ninja supports server mode
  # https://github.com/ninja-build/ninja/issues/2637
  lock = threading.Lock()

  class NinjaHandler(SimpleHTTPRequestHandler):
    def do_GET(self):
      rebuild = self.headers.get('Cache-Control', "") == "no-cache"
      try:
        if self.path == "/":
          patharg = []
        else:
          patharg = [self.translate_path(self.path)]
        if rebuild and (not patharg or not os.path.exists(patharg[0]) or time.time() - os.path.getmtime(patharg[0]) > 60):
          # note: this does not clean the run-time dependencies of patharg,
          # e.g. JS/CSS includes - this information is not tracked by mkwww
          # since it only cares about building the HTML pages i.e. build-time
          # dependencies. unfortunately this means this part is suboptimal in
          # terms of loading speed - the browser will request these includes
          # only after we have rebuilt the HTML page here.
          #
          # fixing this is not worth the effort at present. however, we do a
          # basic mtime check so that multiple requests in quick succession
          # for the same include don't build it repeatedly, a small saving.
          print("mkwww/serve: clean", patharg)
          with lock:
            proc = maybe_ninja(args + ["-t", "clean"] + patharg, capture_output=True)
            proc.check_returncode()
        print("mkwww/serve: build", patharg)
        with lock:
          proc = maybe_ninja(args + patharg, capture_output=True)
          proc.check_returncode()
        return super().do_GET()

      except Exception as e:
        self.send_response(HTTPStatus.INTERNAL_SERVER_ERROR)
        self.send_header("Content-type", "text/plain")
        self.end_headers()
        error = "error building %s:\n\n" % self.path
        self.wfile.write(error.encode("utf-8"))
        self.wfile.write(traceback.format_exc().encode("utf-8"))
        if isinstance(e, subprocess.CalledProcessError):
          self.wfile.write("\nstderr\n======\n\n".encode("utf-8"))
          self.wfile.write(proc.stderr)
          self.wfile.write("\nstdout\n======\n\n".encode("utf-8"))
          self.wfile.write(proc.stdout)
        return

  class NinjaServer(ThreadingHTTPServer):
    def finish_request(self, request, client_address):
      self.RequestHandlerClass(request, client_address, self, directory=DST)

  test(
    HandlerClass=NinjaHandler,
    ServerClass=NinjaServer,
    port=env("PORT", "8000"),
  )

def srcutil(args):
  SRCUTIL_ABS = rp(pj(ENG, "../srcutil"))
  if not args:
    args = ["ls", "-1", SRCUTIL_ABS]
  elif args[0] == "ls":
    args.append(SRCUTIL_ABS)
  else:
    args[0] = pj(SRCUTIL_ABS, args[0])
  print("mkwww/srcutil:", args, file=sys.stderr) # in case user wants to pipe output somewhere
  return subprocess.run(args).returncode

STEPS = {
  "src": (0, srcutil, False),
  "srcutil": (0, srcutil, False),
  "wipe": (0, wipe, True),
  "conf": (1, conf, True),
  "make": (2, make, False),
  "auto": (2, auto, False),
  "serve": (2, serve, False),
}

def extract_steps(args):
  steps = (args[0] if len(args) else "").split(",")
  if len(steps) == 1 and steps[0] not in STEPS:
    # default case, no explicit steps
    steps = ["make"]
  else:
    # explicit steps, pop args
    args = args[1:]

  # if there are args, and all steps want it, append "make" step
  if args and all(STEPS[s][2] for s in steps):
    steps.append("make")

  stepinfo = [STEPS[n] for n in steps]
  if any(y[0] <= x[0] for x, y in zip(stepinfo[:-1], stepinfo[1:])):
    raise ValueError("steps not in sequence: %s" % steps)

  return [s[1] for s in stepinfo], args

def main(*args):
  if not os.path.isdir(SRC):
    raise ValueError("SRC not a directory: %s" % SRC)

  steps, args = extract_steps(list(args))
  return runall((s, args) for s in steps)

if __name__ == "__main__":
  sys.exit(main(*sys.argv[1:]))
