#!/usr/bin/python3
"""
Minimalist engine for building a minimalist static website.

Examples
========

::

  $ mkwww             # Run tests, first building all targets.
  $ mkwww recheck     # Run tests again, even if no source files changed.
  $ mkwww -t clean    # Clean all targets.
  $ mkwww wipe        # Thoroughly clean build directories.
  $ mkwww all         # Build all targets only, don't run tests.
  $ mkwww wipe check  # Wipe, build, then run tests.
  $ mkwww serve check # Serve the site; build and run tests on every request.

Tests include a link checker to ensure no broken links, in both your website
source and the links generated by mkwww.

Usage
=====

Control the source/build directories via envvars::

  THEME = "default" # theme directory, relative to themes directory
  SRC   = "src"     # source input directory
  GEN   = "build"   # intermediate build directory
  DST   = "dist"    # final output for publishing

Control the output via envvars::

  MKWWW_DEV = 1     # Pages auto-refresh after 4s. Useful with ``mkwww serve``

Convenience targets in build.ninja:

``all``:
  Build all targets

``check``:
  Run tests

``recheck``:
  Run tests unconditionally

Fine-grained command control::

  Usage: mkwww [<steps>] <ninja args>

<steps> is a comma-separated (no spaces) list denoting which pre-ninja steps to
run. If not given, ``conf,make`` is implied. Possible steps are:

``wipe``:
  Wipe ``GEN`` and ``DST`` before everything else.

  To help common publishing use-cases, the top-level ``DST`` directory is kept,
  as well as certain special files, e.g. ``.git`` or ``.nojekyll``.

``conf``:
  Detect build configuration and generate build.ninja, unconditionally.

``make``:
  Run ninja with <ninja args>, first generating build.ninja if out-of-date.

``auto``:
  Run ninja with <ninja args>, repeatedly until it fails.

  Good for development when you don't want to keep running mkwww manually.

``serve``:
  Run an HTTP server on port 8000 or the PORT envvar, handling requests by
  first running ninja with <ninja args> <http-request-path>.

  Use shift-reload to force a rebuild of the requested page.

  Use shift-reload on the root path / to force a rebuild of the whole site.

  Good for development when you don't want to run a web server manually.

The steps must be given in sequence, as follows::

  wipe -> conf -> (make | auto)

You can omit any of the steps, as long as what you give is in sequence.
"""

import njinja

import itertools
import json
import os
import subprocess
import sys
import time

env = os.getenv
## variable dirs, read from the environment, set by user
THEME = env("THEME", "default")
SRC = env("SRC", "src")
GEN = env("GEN", "build")
DST = env("DST", "dist")

rel = os.path.relpath
cwd = os.getcwd()
rp = os.path.realpath
pj = os.path.join

## static dirs, relevant to the mkwww installation
BIN_ABS = os.path.dirname(rp(__file__)).removesuffix("/")
BIN     = rel(BIN_ABS, cwd)
ENG_ABS = rp(pj(BIN, ".."))
ENG     = rel(ENG_ABS, cwd)
THM_ABS = rp(pj(ENG, "../themes", THEME))
THM     = rel(THM_ABS, cwd)
ENGSRC  = pj(ENG, "common")
THMSRC  = pj(THM, "common")
# supported formats, extension in upper case.
# to add another format, implement ${BIN}/${fmt}2main then add it to this list
SRC_FORMATS = "MD RST ADOC".split()
CONFIG_GLOBALS = [
  "THEME", "SRC", "GEN", "DST",
  "BIN_ABS", "BIN", "ENG_ABS", "ENG", "THM_ABS", "THM", "ENGSRC", "THMSRC",
  "SRC_FORMATS",
]

## derived variable dirs
CFG = pj(GEN, "build.ninja.json")
OUT = pj(GEN, "build.ninja")
TRUE = ("1", "yes", "on", "true")
FALSE = ("0", "no", "off", "false")
CFGLOADED = False

def detect_pythonpath():
  if env("MKWWW_BIN", ""):
    # running inside mkwww already, e.g. via ninja regenerate
    # in this case "import mkwww" will always succeed even if it should fail
    # so just return the existing value
    return env("PYTHONPATH", "")
  try:
    import mkwww
  except ImportError:
    return "%s/../../lib/python3:%s" % (ENG_ABS, env("PYTHONPATH", ""))

def mk_config():
  bcfg = njinja.BuildConfig()

  PYTHONPATH = detect_pythonpath()
  if not PYTHONPATH:
    del PYTHONPATH
  # only record the config here, we set os.environ later. this decomposes better.
  MKWWW_DEV = env("MKWWW_DEV", "") in TRUE

  def read_site():
    with bcfg.open("%s/site.json" % ENG) as fp:
      e = json.load(fp)
    with bcfg.open("%s/site.json" % SRC) as fp:
      s = json.load(fp)
    t = e | s
    return (t["dir_common"], t["dir_include"], e.get("dir_nodst",[]) + s.get("dir_nodst",[]))

  DIR_COMMON, DIR_INCLUDE, DIR_NODST = read_site()
  ENGDST = pj(DST, DIR_COMMON, "engine")
  THMDST = pj(DST, DIR_COMMON, "theme")

  # TODO: handle the case where GEN/DST are underneath SRC
  SRC_ALL = sorted(filter(lambda x: not any(x.startswith(pj(SRC, p)) for p in [DIR_INCLUDE] + DIR_NODST), bcfg.walk_files(SRC)))
  SRC_D = {}
  IOV_D = {}
  SRC_OV_D = {}
  SRC_NV_D = {}
  INF_OV_D = {}
  INF_NV_D = {}
  INF_D = {}
  DEP_D = {}
  DST_D = {}
  IOV_ALL = []
  INF_OV_ALL = []
  INF_NV_ALL = []
  INF_ALL = []
  SRC_NONCOPY = []
  DEP_NONCOPY = []
  DST_NONCOPY = []

  gen_INF = lambda x: pj(GEN, rel(x, SRC)+".json")
  gen_DEP = lambda x: pj(GEN, rel(x, SRC)+".d")
  dst_SRC = lambda x: pj(DST, rel(x, SRC))
  dst_ENG = lambda x: pj(ENGDST, rel(x, ENGSRC))
  dst_THM = lambda x: pj(THMDST, rel(x, THMSRC))
  re_suf = lambda a, x, y: a.removesuffix(x)+y

  def def_fmt_vars(FMT, ext, isuf, osuf, disj=True, src_all=SRC_ALL):
    SRC_D[FMT] = list(filter(lambda x: x.endswith("."+ext), src_all))
    IOV_D[FMT] = list(filter(lambda x: x.endswith("."+ext+".json"), src_all))
    SRC_OV_D[FMT] = [x.removesuffix(".json") for x in njinja.intersect([x+".json" for x in SRC_D[FMT]], IOV_D[FMT])]
    SRC_NV_D[FMT] = njinja.filterout(SRC_OV_D[FMT], SRC_D[FMT])
    INF_OV_D[FMT] = list(map(gen_INF, SRC_OV_D[FMT]))
    INF_NV_D[FMT] = list(map(gen_INF, SRC_NV_D[FMT]))
    INF_D[FMT] = list(map(gen_INF, SRC_D[FMT]))
    DEP_D[FMT] = list(map(lambda x: gen_DEP(re_suf(x, isuf, osuf)), SRC_D[FMT]))
    DST_D[FMT] = list(map(lambda x: dst_SRC(re_suf(x, isuf, osuf)), SRC_D[FMT]))

    if disj:
      IOV_ALL.extend(IOV_D[FMT])
      INF_OV_ALL.extend(INF_OV_D[FMT])
      INF_NV_ALL.extend(INF_NV_D[FMT])
      INF_ALL.extend(INF_D[FMT])
      SRC_NONCOPY.extend(SRC_D[FMT])
      DEP_NONCOPY.extend(DEP_D[FMT])
      DST_NONCOPY.extend(DST_D[FMT])

  # path variables
  src_non_fmt = set(SRC_ALL)
  for fmt in SRC_FORMATS:
    fmt_ = fmt.lower()
    def_fmt_vars(fmt + "_J2", fmt_ + ".j2", ".%s.j2" % fmt_, ".html")
    def_fmt_vars(fmt, fmt_, "."+fmt_, ".html")
    src_non_fmt -= set(SRC_D[fmt + "_J2"])
  def_fmt_vars("J2", "j2", ".j2", "", src_all=src_non_fmt)
  def_fmt_vars("HTML_J2", "html.j2", ".j2", "", False)

  SRC_SPEC = [ pj(SRC, "site.json") ]
  SRC_COPY = njinja.filterout(IOV_ALL + SRC_SPEC + SRC_NONCOPY, SRC_ALL)
  DST_COPY = list(map(dst_SRC, SRC_COPY))
  DST_ENG = sorted(map(dst_ENG, bcfg.walk_files(ENGSRC)))
  DST_ENG_CSS = list(filter(lambda x: x.endswith(".css"), DST_ENG))
  DST_ENG_COPY = njinja.filterout(DST_ENG_CSS, DST_ENG)
  DST_THM = sorted(map(dst_THM, bcfg.walk_files(THMSRC)))
  DST_ALL = DST_NONCOPY + DST_COPY + DST_ENG + DST_THM

  return bcfg.collect_config(
    locals(),
    globals(),
    lambda k: k in CONFIG_GLOBALS,
    extra_dirs=[GEN, DST, ENG]
  )

def mk_ninja():
  print("mkwww: mk_ninja: configuring:", CFG, OUT)
  config = mk_config()
  MKWWW_NINJA_HEADER = """This file was automatically generated. ANY EDITS WILL BE LOST.

This file expects to be run via mkwww.
You can run it directly via ninja but you may have to ensure the following environment:

""".rstrip().split("\n")
  MKWWW_NINJA_HEADER += ["cd %s" % cwd]
  MKWWW_NINJA_HEADER += ["MKWWW_BIN=%s" % BIN_ABS]
  if "PYTHONPATH" in config:
    MKWWW_NINJA_HEADER += ["PYTHONPATH=%s" % config["PYTHONPATH"]]
  njinja.mk_ninja(
    pj(BIN, "build.ninja.j2"),
    config,
    GEN,
    headers=MKWWW_NINJA_HEADER,
  )
  return config

def wipe(_=None):
  # This is implemented outside of ninja rather than inside as a "phony target"
  # because targets are meant to be additive not subtractive. Implementing
  # subtractive "clean" targets in build systems that cannot distinguish
  # between additive vs subtractive targets (i.e. most if not all of them),
  # causes problems when running targets in parallel.
  import shutil

  if not os.path.isdir(SRC):
    raise ValueError("SRC not a directory: %s" % SRC)

  if os.path.exists(GEN):
    print("mkwww: wipe: removing:", GEN)
    shutil.rmtree(GEN)
  if os.path.exists(DST):
    print("mkwww: wipe: removing contents of:", DST)
    for e in os.scandir(DST):
      if e.is_dir(follow_symlinks=False):
        shutil.rmtree(e.path)
      elif e.name not in (".git", ".nojekyll"): # keep certain files to help with publishing
        os.remove(e.path)

def conf(_=None):
  # This unconditionally builds build.ninja and is therefore appropriate to
  # be defined as generator rule in build.ninja.
  mk_ninja()

def run_with_env(args, **kwargs):
  config = None
  if not os.path.exists(CFG) or not os.path.exists(OUT):
    print("mkwww: run_with_env: not found:", CFG, OUT)
    config = mk_ninja()

  global CFGLOADED
  if not CFGLOADED:
    if config is None:
      with open(CFG) as fp:
        config = json.load(fp)

    if "BIN_ABS" in config:
      os.environ["MKWWW_BIN"] = config["BIN_ABS"]
    if "PYTHONPATH" in config:
      os.environ["PYTHONPATH"] = config["PYTHONPATH"]

    CFGLOADED = True
  return subprocess.run(["ninja", "-f", OUT] + args, **kwargs)

def make(args):
  return run_with_env(args).returncode

def runall(it, sleep=0):
  for f, a in it:
    exitcode = f(a)
    if exitcode:
      return exitcode
    time.sleep(sleep)
  return 0

def auto(args):
  return runall(itertools.repeat((make, args)), 4)

def serve(args):
  import traceback
  from http.server import HTTPStatus, ThreadingHTTPServer, SimpleHTTPRequestHandler, test

  class NinjaHandler(SimpleHTTPRequestHandler):
    def do_GET(self):
      rebuild = self.headers.get('Cache-Control', "") == "no-cache"
      try:
        if self.path == "/":
          patharg = []
        else:
          patharg = [self.translate_path(self.path)]
        if rebuild:
          print("mkwww/serve: clean", patharg)
          proc = run_with_env(args + ["-t", "clean"] + patharg, capture_output=True)
          proc.check_returncode()
        print("mkwww/serve: build", patharg)
        proc = run_with_env(args + patharg, capture_output=True)
        proc.check_returncode()
        return super().do_GET()

      except Exception as e:
        self.send_response(HTTPStatus.INTERNAL_SERVER_ERROR)
        self.send_header("Content-type", "text/plain")
        self.end_headers()
        error = "error building %s:\n\n" % self.path
        self.wfile.write(error.encode("utf-8"))
        self.wfile.write(traceback.format_exc().encode("utf-8"))
        if isinstance(e, subprocess.CalledProcessError):
          self.wfile.write("\nstderr\n======\n\n".encode("utf-8"))
          self.wfile.write(proc.stderr)
          self.wfile.write("\nstdout\n======\n\n".encode("utf-8"))
          self.wfile.write(proc.stdout)
        return

  class NinjaServer(ThreadingHTTPServer):
    def finish_request(self, request, client_address):
      self.RequestHandlerClass(request, client_address, self, directory=DST)

  test(
    HandlerClass=NinjaHandler,
    ServerClass=NinjaServer,
    port=env("PORT", "8000"),
  )

STEPS = {
  "wipe": (0, wipe),
  "conf": (1, conf),
  "make": (2, make),
  "auto": (2, auto),
  "serve": (2, serve),
}

def extract_steps(args):
  steps = (args[0] if len(args) else "").split(",")
  if len(steps) == 1 and steps[0] not in STEPS:
    # default case, no explicit steps
    steps = ["make"]
  else:
    # explicit steps, pop args
    args = args[1:]

  # if there are ninja args, append run step
  if args and STEPS[steps[-1]][0] < STEPS["make"][0]:
    steps.append("make")

  stepinfo = [STEPS[n] for n in steps]
  if any(y[0] <= x[0] for x, y in zip(stepinfo[:-1], stepinfo[1:])):
    raise ValueError("steps not in sequence: %s" % steps)

  return [s[1] for s in stepinfo], args

def main(*args):
  if not os.path.isdir(SRC):
    raise ValueError("SRC not a directory: %s" % SRC)

  steps, args = extract_steps(list(args))
  return runall((s, args) for s in steps)

if __name__ == "__main__":
  sys.exit(main(*sys.argv[1:]))
